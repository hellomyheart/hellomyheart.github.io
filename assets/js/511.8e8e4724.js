(window.webpackJsonp=window.webpackJsonp||[]).push([[511],{930:function(e,r,t){"use strict";t.r(r);var v=t(14),_=Object(v.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"为什么需要前后分离"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要前后分离"}},[e._v("#")]),e._v(" 为什么需要前后分离")]),e._v(" "),t("h3",{attrs:{id:"后端为主的-mvc-时代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后端为主的-mvc-时代"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E5%90%8E%E7%AB%AF%E4%B8%BA%E4%B8%BB%E7%9A%84-mvc-%E6%97%B6%E4%BB%A3",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("后端为主的 MVC 时代")]),e._v(" "),t("p",[e._v("为了降低开发的复杂度，以后端为出发点，比如：Struts、SpringMVC 等框架的使用，就是后端的 MVC 时代;可以参考 "),t("a",{attrs:{href:"https://funtl.com/zh/mvc/%E4%BB%80%E4%B9%88%E6%98%AF-MVC-%E6%A8%A1%E5%BC%8F.html#%E4%BB%80%E4%B9%88%E6%98%AF-mvc-%E6%A8%A1%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"}},[t("strong",[e._v("【什么是 MVC 模式】")]),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("以 "),t("code",[e._v("SpringMVC")]),e._v(" 流程为例：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://zeroone-bucket.oss-cn-beijing.aliyuncs.com/blog/Lusifer2018120811230001.png",alt:"img"}})]),e._v(" "),t("ul",[t("li",[e._v("发起请求到前端控制器("),t("code",[e._v("DispatcherServlet")]),e._v(")")]),e._v(" "),t("li",[e._v("前端控制器请求 "),t("code",[e._v("HandlerMapping")]),e._v(" 查找 "),t("code",[e._v("Handler")]),e._v("，可以根据 "),t("code",[e._v("xml")]),e._v(" 配置、注解进行查找")]),e._v(" "),t("li",[e._v("处理器映射器 "),t("code",[e._v("HandlerMapping")]),e._v(" 向前端控制器返回 "),t("code",[e._v("Handler")])]),e._v(" "),t("li",[e._v("前端控制器调用处理器适配器去执行 "),t("code",[e._v("Handler")])]),e._v(" "),t("li",[e._v("处理器适配器去执行 "),t("code",[e._v("Handler")])]),e._v(" "),t("li",[t("code",[e._v("Handler")]),e._v(" 执行完成给适配器返回 "),t("code",[e._v("ModelAndView")])]),e._v(" "),t("li",[e._v("处理器适配器向前端控制器返回 "),t("code",[e._v("ModelAndView")]),e._v("，"),t("code",[e._v("ModelAndView")]),e._v(" 是 "),t("code",[e._v("SpringMVC")]),e._v(" 框架的一个底层对象，包括 "),t("code",[e._v("Model")]),e._v(" 和 "),t("code",[e._v("View")])]),e._v(" "),t("li",[e._v("前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图("),t("code",[e._v("JSP")]),e._v(")")]),e._v(" "),t("li",[e._v("视图解析器向前端控制器返回 "),t("code",[e._v("View")])]),e._v(" "),t("li",[e._v("前端控制器进行视图渲染，视图渲染将模型数据(在 "),t("code",[e._v("ModelAndView")]),e._v(" 对象中)填充到 "),t("code",[e._v("request")]),e._v(" 域")]),e._v(" "),t("li",[e._v("前端控制器向用户响应结果")])]),e._v(" "),t("h4",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E4%BC%98%E7%82%B9",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("优点")]),e._v(" "),t("p",[e._v("MVC 是一个非常好的协作模式，能够有效降低代码的耦合度，从架构上能够让开发者明白代码应该写在哪里。为了让 View 更纯粹，还可以使用 Thymeleaf、Freemarker 等模板引擎，使模板里无法写入 Java 代码，让前后端分工更加清晰。")]),e._v(" "),t("h4",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E7%BC%BA%E7%82%B9",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("缺点")]),e._v(" "),t("ul",[t("li",[e._v("前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式：\n"),t("ul",[t("li",[e._v("第一种是前端写 DEMO，写好后，让后端去套模板。好处是 DEMO 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大；")]),e._v(" "),t("li",[e._v("另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。")])])]),e._v(" "),t("li",[e._v("前后端职责纠缠不清：模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 "),t("code",[e._v("Controller")]),e._v("，页面路由等功能本应该是前端最关注的，但却是由后端来实现。 "),t("code",[e._v("Controller")]),e._v(" 本身与 "),t("code",[e._v("Model")]),e._v(" 往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在 "),t("code",[e._v("Controller")]),e._v(" 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。")]),e._v(" "),t("li",[e._v("对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用 "),t("a",{attrs:{href:"https://www.ibm.com/developerworks/cn/web/wa-lo-comet/index.html",target:"_blank",rel:"noopener noreferrer"}},[t("strong",[e._v("【Comet】")]),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"https://segmentfault.com/a/1190000002998812",target:"_blank",rel:"noopener noreferrer"}},[t("strong",[e._v("【BigPipe】")]),t("OutboundLink")],1),e._v(" 等技术方案来优化性能。")])]),e._v(" "),t("h2",{attrs:{id:"什么是前后分离"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是前后分离"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("什么是前后分离")]),e._v(" "),t("h3",{attrs:{id:"基于-ajax-带来的-spa-时代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于-ajax-带来的-spa-时代"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E5%9F%BA%E4%BA%8E-ajax-%E5%B8%A6%E6%9D%A5%E7%9A%84-spa-%E6%97%B6%E4%BB%A3",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("基于 AJAX 带来的 SPA 时代")]),e._v(" "),t("p",[e._v("时间回到 2005 年 "),t("code",[e._v("AJAX")]),e._v("（Asynchronous JavaScript And XML，异步 JavaScript 和 XML，老技术新用法） 被正式提出并开始使用 "),t("code",[e._v("CDN")]),e._v(" 作为静态资源存储，于是出现了 JavaScript 王者归来（在这之前 JS 都是用来在网页上贴狗皮膏药广告的）的 SPA（Single Page Application）单页面应用时代。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://zeroone-bucket.oss-cn-beijing.aliyuncs.com/blog/20210408172553.png",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"优点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E4%BC%98%E7%82%B9-2",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("优点")]),e._v(" "),t("p",[e._v("这种模式下，"),t("strong",[e._v("前后端的分工非常清晰，前后端的关键协作点是 "),t("code",[e._v("AJAX")]),e._v(" 接口")]),e._v("。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，"),t("strong",[e._v("这个时代开始出现浏览器端的分层架构")]),e._v("：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://zeroone-bucket.oss-cn-beijing.aliyuncs.com/blog/20210408172641.png",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"缺点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E7%BC%BA%E7%82%B9-2",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("缺点")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("前后端接口的约定：")]),e._v(" 如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。"),t("strong",[e._v("有了和后端一起沉淀的 "),t("code",[e._v("接口规则")]),e._v(" ，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发")]),e._v("。")]),e._v(" "),t("li",[t("strong",[e._v("前端开发的复杂度控制：")]),e._v(" SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。")])]),e._v(" "),t("h3",{attrs:{id:"前端为主的-mv-时代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端为主的-mv-时代"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E5%89%8D%E7%AB%AF%E4%B8%BA%E4%B8%BB%E7%9A%84-mv-%E6%97%B6%E4%BB%A3",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("前端为主的 MV* 时代")]),e._v(" "),t("p",[e._v("此处的 MV* 模式如下：")]),e._v(" "),t("ul",[t("li",[e._v("MVC（同步通信为主）：Model、View、Controller")]),e._v(" "),t("li",[e._v("MVP（异步通信为主）：Model、View、Presenter")]),e._v(" "),t("li",[e._v("MVVM（异步通信为主）：Model、View、ViewModel")])]),e._v(" "),t("p",[e._v("为了降低前端开发复杂度，涌现了大量的前端框架，比如："),t("code",[e._v("AngularJS")]),e._v("、"),t("code",[e._v("React")]),e._v("、"),t("code",[e._v("Vue.js")]),e._v("、"),t("code",[e._v("EmberJS")]),e._v(" 等，这些框架总的原则是先按类型分层，比如 Templates、Controllers、Models，然后再在层内做切分，如下图：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://zeroone-bucket.oss-cn-beijing.aliyuncs.com/blog/20210408172728.png",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"优点-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E4%BC%98%E7%82%B9-3",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("优点")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("前后端职责很清晰：")]),e._v(" 前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。")]),e._v(" "),t("li",[t("strong",[e._v("前端开发的复杂度可控：")]),e._v(" 前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本书的厚度去说明。")]),e._v(" "),t("li",[t("strong",[e._v("部署相对独立：")]),e._v(" 可以快速改进产品体验")])]),e._v(" "),t("h4",{attrs:{id:"缺点-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E7%BC%BA%E7%82%B9-3",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("缺点")]),e._v(" "),t("ul",[t("li",[e._v("代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。")]),e._v(" "),t("li",[e._v("全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。")]),e._v(" "),t("li",[e._v("性能并非最佳，特别是移动互联网环境下。")]),e._v(" "),t("li",[e._v("SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。")])]),e._v(" "),t("h2",{attrs:{id:"nodejs-带来的全栈时代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-带来的全栈时代"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#nodejs-%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%85%A8%E6%A0%88%E6%97%B6%E4%BB%A3",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("NodeJS 带来的全栈时代")]),e._v(" "),t("p",[e._v("前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 NodeJS 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://zeroone-bucket.oss-cn-beijing.aliyuncs.com/blog/20210408172812.png",alt:""}})]),e._v(" "),t("p",[e._v("在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职：")]),e._v(" "),t("ul",[t("li",[e._v("Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。")]),e._v(" "),t("li",[e._v("Back-end UI layer 处理路由、模板、数据获取、Cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。")])]),e._v(" "),t("p",[e._v("通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。")]),e._v(" "),t("p",[e._v("与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。")]),e._v(" "),t("p",[e._v("基于 NodeJS 的全栈模式，依旧面临很多挑战：")]),e._v(" "),t("ul",[t("li",[e._v("需要前端对服务端编程有更进一步的认识。比如 TCP/IP 等网络知识的掌握。")]),e._v(" "),t("li",[e._v("NodeJS 层与 Java 层的高效通信。NodeJS 模式下，都在服务器端，RESTful HTTP 通信未必高效，通过 SOAP 等方式通信更高效。一切需要在验证中前行。")]),e._v(" "),t("li",[e._v("对部署、运维层面的熟练了解，需要更多知识点和实操经验。")]),e._v(" "),t("li",[e._v("大量历史遗留问题如何过渡。这可能是最大最大的阻力。")])]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://funtl.com/zh/vue-prepare/%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2.html#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"}},[e._v("#"),t("OutboundLink")],1),e._v("总结")]),e._v(" "),t("p",[e._v("综上所述，模式也好，技术也罢，没有好坏优劣之分，只有适合不适合；前后分离的开发思想主要是基于 "),t("code",[e._v("SoC")]),e._v("（关注度分离原则），上面种种模式，都是让前后端的职责更清晰，分工更合理高效。")])])}),[],!1,null,null,null);r.default=_.exports}}]);